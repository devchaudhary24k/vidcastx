import { relations } from "drizzle-orm";
import {
  boolean,
  index,
  integer,
  jsonb,
  pgEnum,
  pgTable,
  text,
  timestamp,
  vector,
} from "drizzle-orm/pg-core";

import { generateId } from "../utils/id";
import { videos } from "./video-schema";

export const transcriptStatusEnum = pgEnum("transcript_status", [
  "pending",
  "processing",
  "completed",
  "failed",
]);

export const transcripts = pgTable(
  "transcript",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => generateId("trn")), // Unique identifier for the transcript
    videoId: text("video_id")
      .notNull()
      .references(() => videos.id, { onDelete: "cascade" }), // The video associated with the transcript
    language: text("language").default("en").notNull(), // The language of the transcript
    isOriginal: boolean("is_original").default(true).notNull(), // Whether the transcript is the original one
    isAutoGenerated: boolean("is_auto_generated").default(true).notNull(), // Whether the transcript was auto-generated
    content: text("content").notNull(), // The content of the transcript
    segments: jsonb("segments").default([]).notNull(), // The segments of the transcript
    wordTimings: jsonb("word_timings").default([]), // The word timings of the transcript
    status: transcriptStatusEnum("status").default("pending").notNull(), // The status of the transcript
    provider: text("provider"), // The provider of the transcript service
    confidence: integer("confidence"), // The confidence score of the transcript
    durationProcessed: integer("duration_processed"), // The duration of the audio processed
    errorLog: text("error_log"), // Log of any errors that occurred during transcription
    createdAt: timestamp("created_at").defaultNow().notNull(), // The timestamp when the transcript was created
    updatedAt: timestamp("updated_at")
      .defaultNow()
      .$onUpdate(() => new Date())
      .notNull(), // The timestamp when the transcript was last updated
    deletedAt: timestamp("deleted_at"), // The timestamp when the transcript was deleted
  },
  (table) => [
    index("transcript_videoId_idx").on(table.videoId),
    index("transcript_videoId_language_idx").on(table.videoId, table.language),
  ],
);

export const transcriptEmbeddings = pgTable(
  "transcript_embedding",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => generateId("te")), // Unique identifier for the transcript embedding
    transcriptId: text("transcript_id")
      .notNull()
      .references(() => transcripts.id, { onDelete: "cascade" }), // The transcript associated with the embedding
    videoId: text("video_id")
      .notNull()
      .references(() => videos.id, { onDelete: "cascade" }), // The video associated with the embedding
    segmentIndex: integer("segment_index").notNull(), // The index of the segment
    startTime: integer("start_time").notNull(), // The start time of the segment
    endTime: integer("end_time").notNull(), // The end time of the segment
    text: text("text").notNull(), // The text of the segment
    embedding: vector("embedding", { dimensions: 1536 }), // The vector embedding of the segment
    createdAt: timestamp("created_at").defaultNow().notNull(), // The timestamp when the embedding was created
  },
  (table) => [
    index("embedding_transcriptId_idx").on(table.transcriptId),
    index("embedding_videoId_idx").on(table.videoId),
  ],
);

export const videoChapters = pgTable(
  "video_chapter",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => generateId("chp")), // Unique identifier for the video chapter
    videoId: text("video_id")
      .notNull()
      .references(() => videos.id, { onDelete: "cascade" }), // The video associated with the chapter
    timestamp: integer("timestamp").notNull(), // The timestamp of the chapter
    endTimestamp: integer("end_timestamp"), // The end timestamp of the chapter
    title: text("title").notNull(), // The title of the chapter
    description: text("description"), // The description of the chapter
    thumbnailUrl: text("thumbnail_url"), // The thumbnail URL of the chapter
    isAutoGenerated: boolean("is_auto_generated").default(true).notNull(), // Whether the chapter was auto-generated
    confidence: integer("confidence"), // The confidence score of the chapter
    sortOrder: integer("sort_order").default(0).notNull(), // The sort order of the chapter
    createdAt: timestamp("created_at").defaultNow().notNull(), // The timestamp when the chapter was created
    updatedAt: timestamp("updated_at")
      .defaultNow()
      .$onUpdate(() => new Date())
      .notNull(), // The timestamp when the chapter was last updated
    deletedAt: timestamp("deleted_at"), // The timestamp when the chapter was deleted
  },
  (table) => [
    index("chapter_videoId_idx").on(table.videoId),
    index("chapter_videoId_timestamp_idx").on(table.videoId, table.timestamp),
  ],
);

export const videoSummaries = pgTable(
  "video_summary",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => generateId("vsu")), // Unique identifier for the video summary
    videoId: text("video_id")
      .notNull()
      .references(() => videos.id, { onDelete: "cascade" }), // The video associated with the summary
    language: text("language").default("en").notNull(), // The language of the summary
    shortSummary: text("short_summary"), // A short summary of the video
    mediumSummary: text("medium_summary"), // A medium summary of the video
    longSummary: text("long_summary"), // A long summary of the video
    keyPoints: jsonb("key_points").default([]), // Key points of the video
    topics: jsonb("topics").default([]), // Topics of the video
    seoDescription: text("seo_description"), // SEO description of the video
    provider: text("provider"), // The provider of the summary service
    modelUsed: text("model_used"), // The model used for the summary
    tokensUsed: integer("tokens_used"), // The number of tokens used for the summary
    createdAt: timestamp("created_at").defaultNow().notNull(), // The timestamp when the summary was created
    updatedAt: timestamp("updated_at")
      .defaultNow()
      .$onUpdate(() => new Date())
      .notNull(), // The timestamp when the summary was last updated
    deletedAt: timestamp("deleted_at"), // The timestamp when the summary was deleted
  },
  (table) => [
    index("summary_videoId_idx").on(table.videoId),
    index("summary_videoId_language_idx").on(table.videoId, table.language),
  ],
);

export const transcriptsRelations = relations(transcripts, ({ one, many }) => ({
  video: one(videos, {
    fields: [transcripts.videoId],
    references: [videos.id],
  }),
  embeddings: many(transcriptEmbeddings),
}));

export const transcriptEmbeddingsRelations = relations(
  transcriptEmbeddings,
  ({ one }) => ({
    transcript: one(transcripts, {
      fields: [transcriptEmbeddings.transcriptId],
      references: [transcripts.id],
    }),
    video: one(videos, {
      fields: [transcriptEmbeddings.videoId],
      references: [videos.id],
    }),
  }),
);

export const videoChaptersRelations = relations(videoChapters, ({ one }) => ({
  video: one(videos, {
    fields: [videoChapters.videoId],
    references: [videos.id],
  }),
}));

export const videoSummariesRelations = relations(videoSummaries, ({ one }) => ({
  video: one(videos, {
    fields: [videoSummaries.videoId],
    references: [videos.id],
  }),
}));
